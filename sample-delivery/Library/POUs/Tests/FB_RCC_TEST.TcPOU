<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_RCC_TEST" Id="{601daf38-e4c9-4c7e-b134-2d83b8bfe7a2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RCC_TEST EXTENDS FB_TestSuite
VAR
    fbRCC : FB_RCC;
    stRCC_CTL : ST_RCC;
    stRCC_VRC_01 : ST_VRC;
    stRCC_VRC_02 : ST_VRC;
    stRCC_VRC_03 : ST_VRC;
    stRCC_VRC_04 : ST_VRC;
    stRCC_GCP_01 : ST_VG;
    tTimer1 : TON;
    bInitTest : BOOL := TRUE;
    xSystemOverrideMode_RCC: BOOL := FALSE;

    fbRCC1 : FB_RCC;
    stRCC1_CTL : ST_RCC;
    stRCC_VRC_01_01 : ST_VRC;
    stRCC_VRC_02_01 : ST_VRC;
    stRCC_VRC_03_01 : ST_VRC;
    stRCC_VRC_04_01 : ST_VRC;
    stRCC_GCP_01_01 : ST_VG;
    tTimer1_01 : TON;
    bInitTest_01 : BOOL := TRUE;
    xSystemOverrideMode_RCC_01: BOOL := FALSE;

    fbRCC2 : FB_RCC;
    stRCC2_CTL : ST_RCC;
    stRCC_VRC_01_02 : ST_VRC;
    stRCC_VRC_02_02 : ST_VRC;
    stRCC_VRC_03_02 : ST_VRC;
    stRCC_VRC_04_02 : ST_VRC;
    stRCC_GCP_01_02 : ST_VG;
    tTimer1_02 : TON;
    bInitTest_02 : BOOL := TRUE;
    xSystemOverrideMode_RCC_02: BOOL := FALSE;

    // VARS FOR TestSingleCyleExpectToTransitionThoughOneCycle
    bSeenStateZero : BOOL := FALSE;
    bSeenStateOne : BOOL := FALSE;
    bSeenStateTwo : BOOL := FALSE;
    bSeenStateThree : BOOL := FALSE;
    bSeenStateFour : BOOL := FALSE;
    bSeenStateFive : BOOL := FALSE;

    // VARS FOR TestStopCycleExpectToReturnToIdleState
    iDrainCount : INT := 0;

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[TestSingleCyleExpectToTransitionThoughOneCycle();
TestErrorExpectToTransitionToErroState();
TestStopCycleExpectToReturnToIdleState();]]></ST>
    </Implementation>
    <Method Name="TestErrorExpectToTransitionToErroState" Id="{be7cda11-b5de-4ecd-bb07-02ca724d97e3}">
      <Declaration><![CDATA[METHOD TestErrorExpectToTransitionToErroState : REFERENCE TO FB_Test
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('TestErrorExpectToTransitionToErroState');

tTimer1_01(IN:=TRUE, PT:=T#46S);

IF bInitTest_01 THEN
    stRCC1_CTL.bStartCycle := TRUE;
    bInitTest_01 := FALSE;
    AssertEquals_INT(Expected:= E_RCC_STATES.IDLE,
        Actual:= stRCC1_CTL.eCurrentState,
        Message:= 'DID NOT START IN IDLE STATE');
END_IF

fbRCC1(stRCC_GCP_01:=stRCC_GCP_01_01,
    stRCC_VRC_01:= stRCC_VRC_01_01,
    stRCC_VRC_02:= stRCC_VRC_02_01,
    stRCC_VRC_03:= stRCC_VRC_03_01,
    stRCC_VRC_04:= stRCC_VRC_04_01,
    stRCC_CTL:= stRCC1_CTL
);


IF stRCC1_CTL.eCurrentState = E_RCC_STATES.DRAIN THEN
    // Enable RCC_VRC_03_OPEN_OK SO WE CAN MOVE ONTO NEXT STATE
    (* Valve can open only when CRIX-RCC-GCP-01 reading < setpoint Torr and CRIX-RCC-VRC-01 and 04 are closed*)
    stRCC_GCP_01_01.rPRESS := 0;
    stRCC_GCP_01_01.xPRESS_OK  := FALSE;
    stRCC_VRC_01_01.i_xClsLS := TRUE;
    stRCC_VRC_01_01.q_xOPN_DO := FALSE;
    stRCC_VRC_04_01.i_xClsLS := TRUE;
    stRCC_VRC_04_01.q_xOPN_DO := FALSE;
 END_IF


IF tTimer1_01.Q OR stRCC1_CTL.bError THEN
    AssertEquals_BOOL(Expected:= stRCC1_CTL.bError ,
        Actual:= TRUE,
        Message:= 'ERROR FLAG NOT SET');

    AssertEquals_INT(Expected:=E_RCC_STATES.ERROR ,
        Actual:= stRCC1_CTL.eCurrentState,
        Message:= 'NOT IN ERROR STATE');

    stRCC1_CTL.bClearError := TRUE; // CLEAR ERRORS

    //CYCLE ONE MORE TIME TO SEE IF ERRORS CLEARD
    fbRCC1(stRCC_GCP_01:=stRCC_GCP_01_01,
        stRCC_VRC_01:= stRCC_VRC_01_01,
        stRCC_VRC_02:= stRCC_VRC_02_01,
        stRCC_VRC_03:= stRCC_VRC_03_01,
        stRCC_VRC_04:= stRCC_VRC_04_01,
        stRCC_CTL := stRCC1_CTL
    );


    AssertEquals_BOOL(Expected:= stRCC1_CTL.bError ,
        Actual:= FALSE,
        Message:= 'ERROR FLAG NOT CLEARD');

    AssertEquals_INT(Expected:=E_RCC_STATES.IDLE ,
        Actual:= stRCC1_CTL.eCurrentState,
        Message:= 'NOT IN IDLE STATE');

    TEST_FINISHED();
    bInitTest_01 := TRUE;
    tTimer1_01(IN:=FALSE, PT:=T#46S);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestSingleCyleExpectToTransitionThoughOneCycle" Id="{3c03b652-ff1d-4d2b-b8cf-f86da69ec7c0}">
      <Declaration><![CDATA[METHOD TestSingleCyleExpectToTransitionThoughOneCycle : REFERENCE TO FB_Test
VAR_INPUT
END_VAR
VAR
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('TestSingleCyleExpectToTransitionThoughOneCycle');

tTimer1(IN:=TRUE, PT:=T#46s);

IF bInitTest THEN
    stRCC_CTL.bStartCycle := TRUE;
    bInitTest := FALSE;
    AssertEquals_INT(Expected:= E_RCC_STATES.IDLE,
        Actual:= stRCC_CTL.eCurrentState,
        Message:= 'DID NOT START AT FIRST STATE');
END_IF

fbRCC(stRCC_GCP_01:=stRCC_GCP_01,
    stRCC_VRC_01:= stRCC_VRC_01,
    stRCC_VRC_02:= stRCC_VRC_02,
    stRCC_VRC_03:= stRCC_VRC_03,
    stRCC_VRC_04:= stRCC_VRC_04,
    stRCC_CTL := stRCC_CTL
);

// CHECK IF WE HAVE SEEN ALL THE STATES
IF stRCC_CTL.eCurrentState = E_RCC_STATES.INIT THEN bSeenStateZero := TRUE; END_IF
IF stRCC_CTL.eCurrentState = E_RCC_STATES.OPEN_VRC_02_FOR_T1 THEN bSeenStateOne := TRUE; END_IF
IF stRCC_CTL.eCurrentState = E_RCC_STATES.DRAIN THEN
    // Enable RCC_VRC_03_OPEN_OK SO WE CAN MOVE ONTO NEXT STATE
    (* Valve can open only when CRIX-RCC-GCP-01 reading < setpoint Torr and CRIX-RCC-VRC-01 and 04 are closed*)
    bSeenStateTwo := TRUE;
    stRCC_GCP_01.rPRESS := 0;
    stRCC_GCP_01.xPRESS_OK  := TRUE;
    stRCC_VRC_01.i_xClsLS := TRUE;
    stRCC_VRC_01.q_xOPN_DO := FALSE;
    stRCC_VRC_04.i_xClsLS := TRUE;
    stRCC_VRC_04.q_xOPN_DO := FALSE;
 END_IF
IF stRCC_CTL.eCurrentState = E_RCC_STATES.DRAIN_CHECK THEN bSeenStateThree := TRUE; END_IF
IF stRCC_CTL.eCurrentState = E_RCC_STATES.OPEN_VRC_01_FOR_T3 THEN bSeenStateFour := TRUE; END_IF
IF stRCC_CTL.eCurrentState = E_RCC_STATES.OPEN_VRC_04_FOR_T4 THEN bSeenStateFive :=TRUE; END_IF

        // THIS IS A TEST


IF tTimer1.Q THEN
    // HAVE SE SEEN ALL STAES?
    AssertEquals_BOOL(Expected:= (bSeenStateZero AND
                                    bSeenStateOne AND
                                    bSeenStateTwo AND
                                    bSeenStateThree AND
                                    bSeenStateFour AND
                                    bSeenStateFive),
        Actual:= TRUE,
        Message:= 'HAVE NOT VISITED ALL STATES');
    TEST_FINISHED();
    bInitTest := TRUE;
    tTimer1(IN:=FALSE, PT:=T#46S);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="TestStopCycleExpectToReturnToIdleState" Id="{b681e18c-3a41-4dc6-bab7-3a3f4baaa0ad}">
      <Declaration><![CDATA[METHOD TestStopCycleExpectToReturnToIdleState : REFERENCE TO FB_Test
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[TEST('TestStopCycleExpectToReturnToIdleState');

tTimer1_02(PT:=T#500ms);

IF bInitTest_02 THEN
    stRCC2_CTL.bStartCycle := TRUE;
    bInitTest_02 := FALSE;
    tTimer1_02.IN:=FALSE;
    AssertEquals_INT(Expected:= E_RCC_STATES.IDLE,
        Actual:= stRCC2_CTL.eCurrentState,
        Message:= 'DID NOT START AT FIRST STATE');
END_IF

fbRCC2(	stRCC_GCP_01:= stRCC_GCP_01_02,
        stRCC_VRC_01:= stRCC_VRC_01_02,
        stRCC_VRC_02:= stRCC_VRC_02_02,
        stRCC_VRC_03:= stRCC_VRC_03_02,
        stRCC_VRC_04:= stRCC_VRC_04_02,
        stRCC_CTL := stRCC2_CTL
);

IF stRCC2_CTL.eCurrentState = E_RCC_STATES.DRAIN THEN
    // Enable RCC_VRC_03_OPEN_OK SO WE CAN MOVE ONTO NEXT STATE
    (* Valve can open only when CRIX-RCC-GCP-01 reading < setpoint Torr and CRIX-RCC-VRC-01 and 04 are closed*)
    stRCC_GCP_01_02.rPRESS := 20;
    stRCC_GCP_01_02.xPRESS_OK  := TRUE;
    stRCC_VRC_01_02.i_xClsLS := TRUE;
    stRCC_VRC_01_02.q_xOPN_DO := FALSE;
    stRCC_VRC_04_02.i_xClsLS := TRUE;
    stRCC_VRC_04_02.q_xOPN_DO := FALSE;
    tTimer1_02.IN:=TRUE;
    stRCC2_CTL.bStop := TRUE;
 END_IF


IF tTimer1_02.Q THEN
    AssertEquals_INT(Expected:= E_RCC_STATES.IDLE,
        Actual:= stRCC2_CTL.eCurrentState,
        Message:= 'DID NOT END IN IDLE STATE');
    TEST_FINISHED();
    bInitTest_02 := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>